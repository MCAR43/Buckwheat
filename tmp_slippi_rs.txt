use serde::{Deserialize, Serialize};
use crate::app_state::AppState;
use crate::commands::errors::Error;
use crate::game_detector::{slippi_paths, GameDetector};
use crate::recorder;
use std::path::PathBuf;
use tauri::State;
use sysinfo::System;

#[cfg(target_os = "windows")]
use windows::Win32::Foundation::{BOOL, HWND, LPARAM, RECT};
#[cfg(target_os = "windows")]
use windows::Win32::UI::WindowsAndMessaging::{
    EnumWindows, EnumChildWindows, GetWindowTextW, GetWindowRect, IsWindowVisible, 
    GetWindowThreadProcessId, GetClassNameW, GetWindow, GW_OWNER
};
#[cfg(target_os = "windows")]
use windows::Win32::Graphics::Dwm::{DwmGetWindowAttribute, DWMWA_CLOAKED};
#[cfg(target_os = "windows")]
use windows::Win32::Graphics::Gdi::MonitorFromWindow;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct GameWindow {
    pub process_name: String,
    pub window_title: String,
    pub width: i32,
    pub height: i32,
    pub process_id: u32,
    pub class_name: String,
    pub is_cloaked: bool,
    pub is_child: bool,
    pub has_owner: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RecordingSession {
    pub id: String,
    pub start_time: String,
    pub end_time: Option<String>,
    pub slp_path: String,
    pub video_path: Option<String>,
    pub duration: Option<u64>,
}

/// Get the default Slippi replay folder path for the current OS
#[tauri::command]
pub fn get_default_slippi_path() -> Result<String, Error> {
    let path = slippi_paths::get_default_slippi_path();

    path.to_str()
        .map(|s| s.to_string())
        .ok_or_else(|| Error::InvalidPath("Failed to convert path to string".to_string()))
}

/// Start watching for new Slippi games
#[tauri::command]
pub async fn start_watching(path: String, state: State<'_, AppState>) -> Result<(), Error> {
    log::info!("üìÅ Starting to watch Slippi folder: {}", path);
    
    let slippi_path = PathBuf::from(&path);
    
    // Check if path exists
    if !slippi_path.exists() {
        return Err(Error::InvalidPath(format!(
            "Slippi folder does not exist: {}",
            path
        )));
    }
    
    // Create new GameDetector
    let mut detector = GameDetector::new(slippi_path);
    detector.start_watching()?;
    
    // Store in app state
    let mut game_detector = state.game_detector.lock().map_err(|e| {
        Error::InitializationError(format!("Failed to lock game detector: {}", e))
    })?;
    *game_detector = Some(detector);
    
    log::info!("‚úÖ Now watching for .slp files");
    Ok(())
}

/// Stop watching for new games
#[tauri::command]
pub async fn stop_watching(state: State<'_, AppState>) -> Result<(), Error> {
    log::info!("‚èπÔ∏è  Stopping file watcher");
    
    let mut game_detector = state.game_detector.lock().map_err(|e| {
        Error::InitializationError(format!("Failed to lock game detector: {}", e))
    })?;
    
    if let Some(detector) = game_detector.as_mut() {
        detector.stop_watching();
    }
    
    *game_detector = None;
    log::info!("‚úÖ File watcher stopped");
    Ok(())
}

/// Start recording gameplay
#[tauri::command]
pub async fn start_recording(output_path: String, state: State<'_, AppState>) -> Result<(), Error> {
    log::info!("üé• Starting recording to: {}", output_path);
    
    // Get or create recorder
    let mut recorder_lock = state.recorder.lock().map_err(|e| {
        Error::InitializationError(format!("Failed to lock recorder: {}", e))
    })?;
    
    // Create new recorder if none exists
    if recorder_lock.is_none() {
        *recorder_lock = Some(recorder::get_recorder());
    }
    
    // Start recording
    if let Some(recorder) = recorder_lock.as_mut() {
        recorder.start_recording(&output_path)?;
        log::info!("‚úÖ Recording started successfully");
        Ok(())
    } else {
        Err(Error::InitializationError(
            "Failed to initialize recorder".to_string(),
        ))
    }
}

/// Stop recording gameplay
#[tauri::command]
pub async fn stop_recording(state: State<'_, AppState>) -> Result<String, Error> {
    log::info!("‚èπÔ∏è  Stopping recording");
    
    let mut recorder_lock = state.recorder.lock().map_err(|e| {
        Error::RecordingFailed(format!("Failed to lock recorder: {}", e))
    })?;
    
    if let Some(recorder) = recorder_lock.as_mut() {
        let output_path = recorder.stop_recording()?;
        log::info!("‚úÖ Recording stopped: {}", output_path);
        
        // Clean up recorder
        *recorder_lock = None;
        
        Ok(output_path)
    } else {
        Err(Error::RecordingFailed(
            "No active recording to stop".to_string(),
        ))
    }
}

/// Get list of recorded sessions
#[tauri::command]
pub fn get_recordings() -> Result<Vec<RecordingSession>, Error> {
    let mock_recordings = vec![
        RecordingSession {
            id: "1".to_string(),
            start_time: "2025-11-06T12:00:00Z".to_string(),
            end_time: Some("2025-11-06T12:05:00Z".to_string()),
            slp_path: "/path/to/game1.slp".to_string(),
            video_path: Some("/path/to/game1.mp4".to_string()),
            duration: Some(300),
        },
        RecordingSession {
            id: "2".to_string(),
            start_time: "2025-11-06T13:00:00Z".to_string(),
            end_time: Some("2025-11-06T13:03:30Z".to_string()),
            slp_path: "/path/to/game2.slp".to_string(),
            video_path: Some("/path/to/game2.mp4".to_string()),
            duration: Some(210),
        },
    ];

    Ok(mock_recordings)
}

#[cfg(target_os = "windows")]
struct ChildEnumContext {
    windows: Vec<GameWindow>,
    parent_pid: u32,
}

/// Enumerate all windows and find potential game windows (Windows-specific)
#[cfg(target_os = "windows")]
#[tauri::command]
pub fn list_game_windows() -> Result<Vec<GameWindow>, Error> {
    use std::collections::HashMap;
    
    log::info!("üîç Enumerating windows to find game candidates...");
    
    // First, get all processes with sysinfo
    let mut sys = System::new_all();
    sys.refresh_processes(sysinfo::ProcessesToUpdate::All);
    
    // Map PIDs to process names
    let mut pid_to_name: HashMap<u32, String> = HashMap::new();
    for (pid, process) in sys.processes() {
        pid_to_name.insert(pid.as_u32(), process.name().to_string_lossy().to_string());
    }
    
    let mut windows: Vec<GameWindow> = Vec::new();
    
    unsafe {
        // Enumerate all top-level windows
        let _ = EnumWindows(
            Some(enum_windows_callback),
            LPARAM(&mut windows as *mut Vec<GameWindow> as isize),
        );
        
        // Note: We intentionally avoid the previous PID-based child scan here
        // because it produced large duplicate sets. If needed, we can add a
        // proper per-parent `EnumChildWindows` pass in a follow-up.
    }
    
    // Attach process names using the PID->name map
    for w in &mut windows {
        if let Some(name) = pid_to_name.get(&w.process_id) {
            w.process_name = name.clone();
        }
    }

    // Heuristic scoring to prioritize the actual render/game window
    fn score_window(w: &GameWindow) -> i32 {
        let mut s = 0;
        let title = w.window_title.to_lowercase();
        if title.contains("slippi") || title.contains("melee") || title.contains("dolphin") { s += 3; }
        if title.contains("launcher") || title.contains("settings") || title.contains("configuration") { s -= 3; }
        if w.width >= 640 && w.height >= 480 && !w.is_cloaked { s += 3; }
        // Owner often indicates dialogs; don't boost here
        if w.height > 0 {
            let ar = (w.width as f32) / (w.height as f32);
            let d43 = (ar - (4.0/3.0)).abs();
            let d169 = (ar - (16.0/9.0)).abs();
            if d43 < 0.08 || d169 < 0.08 { s += 2; }
        }
        let class = w.class_name.to_lowercase();
        if class.contains("dolphin") || class.contains("wxwindownr") { s += 3; }
        if class.starts_with("#32770") || class.contains("tooltips") { s -= 4; }
        s
    }

    // Pre-filter to likely Dolphin/Slippi candidates and sensible sizes
    let prefiltered: Vec<GameWindow> = windows
        .clone()
        .into_iter()
        .filter(|w| {
            let pn = w.process_name.to_lowercase();
            let tl = w.window_title.to_lowercase();
            let cn = w.class_name.to_lowercase();
            let keyword = pn.contains("dolphin") || pn.contains("slippi") || pn.contains("melee")
                || tl.contains("slippi") || tl.contains("melee") || tl.contains("dolphin")
                || cn.contains("wxwindownr");
            keyword && w.width >= 640 && w.height >= 480 && !w.is_cloaked
        })
        .collect();

    // Build a scored candidate list; if empty fall back to the legacy filter
    let mut scored: Vec<GameWindow> = prefiltered
        .into_iter()
        .filter(|w| score_window(w) >= 2)
        .collect();
    scored.sort_by_key(|w| -score_window(w));
    
    // Filter for likely game windows (prefer scored results)
    let mut game_windows: Vec<GameWindow> = if !scored.is_empty() { scored } else {
        windows
            .into_iter()
            .filter(|w| {
                let title_lower = w.window_title.to_lowercase();
                (title_lower.contains("slippi")
                    || title_lower.contains("melee")
                    || title_lower.contains("dolphin"))
                    && !title_lower.contains("launcher")
                    && !title_lower.contains("settings")
                    && !title_lower.contains("configuration")
                    && w.width >= 640
                    && w.height >= 480
                    && !w.is_cloaked
            })
            .collect()
    };

    // De-duplicate by (pid,title,size,class)
    {
        use std::collections::HashSet;
        let mut seen: HashSet<String> = HashSet::new();
        game_windows.retain(|w| {
            let key = format!("{}:{}x{}:{}:{}", w.process_id, w.width, w.height, w.class_name, w.window_title);
            seen.insert(key)
        });
    }
    
    log::info!("‚úÖ Found {} potential game windows", game_windows.len());
    for window in &game_windows {
        log::info!(
            "  - PID: {} | Title: {} | Size: {}x{} | Class: {} | Cloaked: {} | Child: {} | HasOwner: {}", 
            window.process_id,
            window.window_title, 
            window.width, 
            window.height,
            window.class_name,
            window.is_cloaked,
            window.is_child,
            window.has_owner
        );
    }
    
    Ok(game_windows)
}

#[cfg(target_os = "windows")]
unsafe extern "system" fn enum_windows_callback(hwnd: HWND, lparam: LPARAM) -> BOOL {
    let windows = &mut *(lparam.0 as *mut Vec<GameWindow>);
    
    // Process all windows (not just visible ones, to catch more possibilities)
    // Get window title (might be empty for some windows)
    let mut title: [u16; 512] = [0; 512];
    let len = GetWindowTextW(hwnd, &mut title);
    let window_title = if len > 0 {
        String::from_utf16_lossy(&title[..len as usize])
    } else {
        "(No Title)".to_string()
    };
    
    // Get window dimensions
    let mut rect = RECT::default();
    if GetWindowRect(hwnd, &mut rect).is_ok() {
        let width = rect.right - rect.left;
        let height = rect.bottom - rect.top;
        
        // Get process ID
        let mut process_id: u32 = 0;
        GetWindowThreadProcessId(hwnd, Some(&mut process_id));
        
        // Get window class name
        let mut class_name: [u16; 256] = [0; 256];
        let class_len = GetClassNameW(hwnd, &mut class_name);
        let class_name_str = if class_len > 0 {
            String::from_utf16_lossy(&class_name[..class_len as usize])
        } else {
            "Unknown".to_string()
        };
        
        // Check if window is cloaked (hidden but still visible)
        let mut is_cloaked = 0u32;
        let cloaked = DwmGetWindowAttribute(
            hwnd,
            DWMWA_CLOAKED,
            &mut is_cloaked as *mut _ as *mut _,
            std::mem::size_of::<u32>() as u32,
        ).is_ok() && is_cloaked != 0;
        
        // Check if window has an owner (owned windows are often dialogs/popups)
        let has_owner = GetWindow(hwnd, GW_OWNER)
            .map(|h| !h.is_invalid())
            .unwrap_or(false);
        
        windows.push(GameWindow {
            process_name: format!("PID: {}", process_id),
            window_title: window_title.clone(),
            width,
            height,
            process_id,
            class_name: class_name_str,
            is_cloaked: cloaked,
            is_child: false, // Top-level windows are not children
            has_owner,
        });
    }
    
    BOOL::from(true) // Continue enumeration
}

#[cfg(target_os = "windows")]
unsafe extern "system" fn enum_child_windows_callback(hwnd: HWND, lparam: LPARAM) -> BOOL {
    let context = &mut *(lparam.0 as *mut ChildEnumContext);
    
    // Get process ID for this window
    let mut process_id: u32 = 0;
    GetWindowThreadProcessId(hwnd, Some(&mut process_id));
    
    // Only process windows from the same process as parent
    if process_id == context.parent_pid {
        let mut title: [u16; 512] = [0; 512];
        let len = GetWindowTextW(hwnd, &mut title);
        let window_title = if len > 0 {
            String::from_utf16_lossy(&title[..len as usize])
        } else {
            "(No Title - Child)".to_string()
        };
        
        let mut rect = RECT::default();
        if GetWindowRect(hwnd, &mut rect).is_ok() {
            let width = rect.right - rect.left;
            let height = rect.bottom - rect.top;
            
            let mut class_name: [u16; 256] = [0; 256];
            let class_len = GetClassNameW(hwnd, &mut class_name);
            let class_name_str = if class_len > 0 {
                String::from_utf16_lossy(&class_name[..class_len as usize])
            } else {
                "Unknown".to_string()
            };
            
            let mut is_cloaked = 0u32;
            let cloaked = DwmGetWindowAttribute(
                hwnd,
                DWMWA_CLOAKED,
                &mut is_cloaked as *mut _ as *mut _,
                std::mem::size_of::<u32>() as u32,
            ).is_ok() && is_cloaked != 0;
            
            let has_owner = GetWindow(hwnd, GW_OWNER)
                .map(|h| !h.is_invalid())
                .unwrap_or(false);
            
            // Only add if it has reasonable dimensions
            if width > 100 && height > 100 {
                context.windows.push(GameWindow {
                    process_name: format!("PID: {} (Child)", process_id),
                    window_title,
                    width,
                    height,
                    process_id,
                    class_name: class_name_str,
                    is_cloaked: cloaked,
                    is_child: true,
                    has_owner,
                });
            }
        }
    }
    
    BOOL::from(true) // Continue enumeration
}

/// List game windows (stub for non-Windows platforms)
#[cfg(not(target_os = "windows"))]
#[tauri::command]
pub fn list_game_windows() -> Result<Vec<GameWindow>, Error> {
    Ok(vec![])
}

/// Check if the Slippi/Dolphin game window is currently open
/// Uses the stored process name from settings, or falls back to auto-detection
#[tauri::command]
pub async fn check_game_window(state: State<'_, AppState>) -> Result<bool, Error> {
    // Read stored identifier (may include PID)
    let settings = state.settings.lock().map_err(|e| {
        Error::InitializationError(format!("Failed to lock settings: {}", e))
    })?;
    let stored_id = settings
        .get("game_process_name")
        .and_then(|v| v.as_str())
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty());
    
    drop(settings); // Release lock
    
    // Windows: use window enumeration + scoring to detect the actual game window
    #[cfg(target_os = "windows")]
    {
        use sysinfo::System;

        let mut windows: Vec<GameWindow> = Vec::new();
        unsafe {
            let _ = EnumWindows(
                Some(enum_windows_callback),
                LPARAM(&mut windows as *mut Vec<GameWindow> as isize),
            );
            let copy = windows.clone();
            for parent in copy {
                let mut ctx = ChildEnumContext { windows: Vec::new(), parent_pid: parent.process_id };
                EnumWindows(
                    Some(enum_child_windows_callback),
                    LPARAM(&mut ctx as *mut ChildEnumContext as isize),
                );
                windows.extend(ctx.windows);
            }
        }

        // Attach process names
        let mut sys = System::new_all();
        sys.refresh_processes(sysinfo::ProcessesToUpdate::All);
        for w in &mut windows {
            if let Some(p) = sys.process(sysinfo::Pid::from_u32(w.process_id)) {
                w.process_name = p.name().to_string_lossy().to_string();
            }
        }

        // Optional narrowing from stored selection
        let mut pid_filter: Option<u32> = None;
        let mut title_filter: Option<String> = None;
        if let Some(id) = stored_id.clone() {
            if let Some(pos) = id.find("PID:") {
                let after = id[pos + 4..].trim_start();
                let digits: String = after.chars().take_while(|c| c.is_ascii_digit()).collect();
                pid_filter = digits.parse::<u32>().ok();
            } else {
                title_filter = Some(id.to_lowercase());
            }
        }

        fn score_window(w: &GameWindow) -> i32 {
            let mut s = 0;
            let t = w.window_title.to_lowercase();
            if t.contains("slippi") || t.contains("melee") || t.contains("dolphin") { s += 3; }
            if t.contains("launcher") || t.contains("settings") || t.contains("configuration") { s -= 3; }
            if w.width >= 640 && w.height >= 480 && !w.is_cloaked { s += 3; }
            // Owner can indicate dialogs; don't boost
            if w.height > 0 {
                let ar = (w.width as f32) / (w.height as f32);
                let d43 = (ar - (4.0/3.0)).abs();
                let d169 = (ar - (16.0/9.0)).abs();
                if d43 < 0.08 || d169 < 0.08 { s += 2; }
            }
            let c = w.class_name.to_lowercase();
            if c.contains("dolphin") || c.contains("wxwindownr") { s += 3; }
            if c.starts_with("#32770") || c.contains("tooltips") { s -= 4; }
            s
        }

        let mut candidates: Vec<&GameWindow> = windows.iter().collect();
        if let Some(pid) = pid_filter { candidates.retain(|w| w.process_id == pid); }
        if let Some(ref tf) = title_filter { candidates.retain(|w| w.window_title.to_lowercase().contains(tf)); }
        if pid_filter.is_none() && title_filter.is_none() {
            candidates.retain(|w| {
                let pn = w.process_name.to_lowercase();
                pn.contains("dolphin") || pn.contains("slippi") || pn.contains("melee")
            });
        }

        let best = candidates.into_iter().max_by_key(|w| score_window(w));
        if let Some(w) = best { return Ok(score_window(w) >= 4); }
        return Ok(false);
    }

    if let Some(process_name) = Option::<String>::None {
        log::debug!("üéÆ Checking for stored process: {}", process_name);
        return Ok(check_process_exists(&process_name));
    }
    
    // Fallback: auto-detect using common names
    log::debug!("üéÆ No stored process, using auto-detection");
    let default_names = [
        "Slippi Dolphin.exe",
        "Slippi Dolphin",
        "Dolphin.exe",
    ];
    
    for name in &default_names {
        if check_process_exists(name) {
            log::debug!("üéÆ Found process via auto-detection: {}", name);
            return Ok(true);
        }
    }
    
    log::debug!("‚ùå No Slippi process found");
    Ok(false)
}

/// Helper function to check if a process exists
fn check_process_exists(process_name: &str) -> bool {
    let mut sys = System::new_all();
    sys.refresh_processes(sysinfo::ProcessesToUpdate::All);
    
    for process in sys.processes().values() {
        let name = process.name().to_string_lossy();
        if name.as_ref() == process_name || name.contains(process_name) {
            return true;
        }
    }
    
    false
}

/// Get the stored or detected game process name
#[tauri::command]
pub async fn get_game_process_name(state: State<'_, AppState>) -> Result<Option<String>, Error> {
    let settings = state.settings.lock().map_err(|e| {
        Error::InitializationError(format!("Failed to lock settings: {}", e))
    })?;
    
    Ok(settings.get("game_process_name")
        .and_then(|v| v.as_str())
        .map(|s| s.to_string()))
}

/// Set the game process name to use for detection and recording
#[tauri::command]
pub async fn set_game_process_name(
    process_name: String,
    state: State<'_, AppState>
) -> Result<(), Error> {
    log::info!("üíæ Setting game process name to: {}", process_name);
    
    let mut settings = state.settings.lock().map_err(|e| {
        Error::InitializationError(format!("Failed to lock settings: {}", e))
    })?;
    
    settings.insert("game_process_name".to_string(), serde_json::Value::String(process_name));
    
    Ok(())
}


